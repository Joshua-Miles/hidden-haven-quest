<html>
    <head>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css"/>
    </head>
    <body>
        <h1>Lets Go!!!</h1>
        <script src="jsQR.js"></script>
        <script>
            
            let ImageCapture = window.ImageCapture;

            if (true) {
            ImageCapture = class {

                /**
                 * TODO https://www.w3.org/TR/image-capture/#constructors
                 *
                 * @param {MediaStreamTrack} videoStreamTrack - A MediaStreamTrack of the 'video' kind
                 */
                constructor(videoStreamTrack) {
                if (videoStreamTrack.kind !== 'video')
                    throw new DOMException('NotSupportedError');

                this._videoStreamTrack = videoStreamTrack;
                if (!('readyState' in this._videoStreamTrack)) {
                    // Polyfill for Firefox
                    this._videoStreamTrack.readyState = 'live';
                }

                // MediaStream constructor not available until Chrome 55 - https://www.chromestatus.com/feature/5912172546752512
                this._previewStream = new MediaStream([videoStreamTrack]);
                this.videoElement = document.createElement('video');
                this.videoElementPlaying = new Promise(resolve => {
                    this.videoElement.addEventListener('playing', resolve);
                });
                if (HTMLMediaElement) {
                    this.videoElement.srcObject = this._previewStream;  // Safari 11 doesn't allow use of createObjectURL for MediaStream
                } else {
                    this.videoElement.src = URL.createObjectURL(this._previewStream);
                }
                this.videoElement.muted = true;
                this.videoElement.setAttribute('playsinline', ''); // Required by Safari on iOS 11. See https://webkit.org/blog/6784
                this.videoElement.play();

                this.canvasElement = document.createElement('canvas');
                // TODO Firefox has https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas
                this.canvas2dContext = this.canvasElement.getContext('2d');
                }

                /**
                 * https://w3c.github.io/mediacapture-image/index.html#dom-imagecapture-videostreamtrack
                 * @return {MediaStreamTrack} The MediaStreamTrack passed into the constructor
                 */
                get videoStreamTrack() {
                return this._videoStreamTrack;
                }

                /**
                 * Implements https://www.w3.org/TR/image-capture/#dom-imagecapture-getphotocapabilities
                 * @return {Promise<PhotoCapabilities>} Fulfilled promise with
                 * [PhotoCapabilities](https://www.w3.org/TR/image-capture/#idl-def-photocapabilities)
                 * object on success, rejected promise on failure
                 */
                getPhotoCapabilities() {
                return new Promise(function executorGPC(resolve, reject) {
                    // TODO see https://github.com/w3c/mediacapture-image/issues/97
                    const MediaSettingsRange = {
                    current: 0, min: 0, max: 0,
                    };
                    resolve({
                    exposureCompensation: MediaSettingsRange,
                    exposureMode: 'none',
                    fillLightMode: 'none',
                    focusMode: 'none',
                    imageHeight: MediaSettingsRange,
                    imageWidth: MediaSettingsRange,
                    iso: MediaSettingsRange,
                    redEyeReduction: false,
                    whiteBalanceMode: 'none',
                    zoom: MediaSettingsRange,
                    });
                    reject(new DOMException('OperationError'));
                });
                }

                /**
                 * Implements https://www.w3.org/TR/image-capture/#dom-imagecapture-setoptions
                 * @param {Object} photoSettings - Photo settings dictionary, https://www.w3.org/TR/image-capture/#idl-def-photosettings
                 * @return {Promise<void>} Fulfilled promise on success, rejected promise on failure
                 */
                setOptions(photoSettings = {}) {
                return new Promise(function executorSO(resolve, reject) {
                    // TODO
                });
                }

                /**
                 * TODO
                 * Implements https://www.w3.org/TR/image-capture/#dom-imagecapture-takephoto
                 * @return {Promise<Blob>} Fulfilled promise with [Blob](https://www.w3.org/TR/FileAPI/#blob)
                 * argument on success; rejected promise on failure
                 */
                takePhoto() {
                const self = this;
                return new Promise(function executorTP(resolve, reject) {
                    // `If the readyState of the MediaStreamTrack provided in the constructor is not live,
                    // return a promise rejected with a new DOMException whose name is "InvalidStateError".`
                    if (self._videoStreamTrack.readyState !== 'live') {
                    return reject(new DOMException('InvalidStateError'));
                    }
                    self.videoElementPlaying.then(() => {
                    try {
                        self.canvasElement.width = self.videoElement.videoWidth;
                        self.canvasElement.height = self.videoElement.videoHeight;
                        self.canvas2dContext.drawImage(self.videoElement, 0, 0);
                        self.canvasElement.toBlob(resolve);
                    } catch (error) {
                        reject(new DOMException('UnknownError'));
                    }
                    });
                });
                }

                /**
                 * Implements https://www.w3.org/TR/image-capture/#dom-imagecapture-grabframe
                 * @return {Promise<ImageBitmap>} Fulfilled promise with
                 * [ImageBitmap](https://www.w3.org/TR/html51/webappapis.html#webappapis-images)
                 * argument on success; rejected promise on failure
                 */
                grabFrame() {
                const self = this;
                return new Promise(function executorGF(resolve, reject) {
                    // `If the readyState of the MediaStreamTrack provided in the constructor is not live,
                    // return a promise rejected with a new DOMException whose name is "InvalidStateError".`
                    if (self._videoStreamTrack.readyState !== 'live') {
                    return reject(new DOMException('InvalidStateError'));
                    }
                    self.videoElementPlaying.then(() => {
                    try {
                        self.canvasElement.width = self.videoElement.videoWidth;
                        self.canvasElement.height = self.videoElement.videoHeight;
                        self.canvas2dContext.drawImage(self.videoElement, 0, 0);
                        // TODO polyfill https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmapFactories/createImageBitmap for IE
                        let frame = window.createImageBitmap(self.canvasElement)
                        resolve(frame);
                    } catch (error) {
                        alert(error)
                        // reject(new DOMException('UnknownError'));
                    }
                    });
                });
                }
            };
            }


            window.ImageCapture = ImageCapture;
            (async function(){ 
                const mediaStream = await navigator.mediaDevices.getUserMedia({video: { facingMode:  "environment"  } })
                const canvas = document.createElement('canvas')
                const ctx = canvas.getContext('2d')
                const track = mediaStream.getVideoTracks()[0];
                let imageCapture = new ImageCapture(track);
                let video = imageCapture.videoElement
                document.body.append(video)
                let search = async function(){
                    canvas.width = video.videoWidth
                    canvas.height = video.videoHeight
                    ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight)
                    if(!video.videoWidth || !video.videoHeight) return setTimeout(search, 1000)
                    let imageData = ctx.getImageData(0, 0, video.videoWidth, video.videoHeight);
                    let code = jsQR(imageData.data, video.videoWidth, video.videoHeight)
                    if(!code) setTimeout(search, 1000)
                    else {
                        alert(code.data)
                    }
                
                }
                search()  
            })()
        </script>
    </body>
    
</html>